import java.awt.Dimension;
import java.awt.Image;
import java.awt.Toolkit;
import javax.swing.*;

public class TopClass {
	//global constant variables
	private static final int SCREEN_WIDTH = (int) Toolkit.getDefaultToolkit().getScreenSize().getWidth();
        private static final int SCREEN_HEIGHT = (int) Toolkit.getDefaultToolkit().getScreenSize().getHeight();
        //global variables
	//global swing objects
	private JFrame f = new JFrame("Flappy Bird Redux");
	
	//other global objects
	private static TopClass tc = new TopClass();
	
	/**
	 * Default constructor
	 */
	public TopClass() {
	}
	
	/**
	 * Main executable method invoked when running .jar file
	 * @param args
	 */
	public static void main(String[] args) {
		//build the GUI on a new thread
		
		javax.swing.SwingUtilities.invokeLater(new Runnable() {
			public void run() {
				tc.buildFrame();
				//create a new thread to keep the GUI responsive while the game runs
				Thread t = new Thread() {
					public void run() {
						//in here we will call a function to start the game
					}
				};
				t.start();
			}
		});
	}
	
	/**
	 * Method to construct the JFrame and add the program content
	 */
	private void buildFrame() {
	        Image icon = Toolkit.getDefaultToolkit().getImage(this.getClass().getResource("resources/blue_bird.png"));
	        f.setContentPane(createContentPane()); //adds the main content to the frame
                f.setResizable(true); //true, but game will not function properly unless maximized!
                f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                f.setAlwaysOnTop(false);
                f.setVisible(true);
                f.setMinimumSize(new Dimension(SCREEN_WIDTH*1/4, SCREEN_HEIGHT*1/4)); //set to prevent collapse to tiny window upon resizing
                f.setExtendedState(JFrame.MAXIMIZED_BOTH); //maximize the JFrame
                f.setIconImage(icon); //set the icon
	}
	
	private JPanel createContentPane() {
		topPanel = new JPanel(); //top-most JPanel in layout hierarchy
		return topPanel; //return a blank panel
	}
}

import java.awt.Graphics;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.awt.Image;
import java.awt.image.BufferedImage;

public class Bird {
	//global variables
	private Image flappyBird;
	private int xLoc = 0, yLoc = 0;
	
	/**
	 * Default constructor
	 */
	public Bird(int initialWidth, int initialHeight) {
		flappyBird = Toolkit.getDefaultToolkit().getImage(this.getClass().getResource("resources/blue_bird.png"));
		scaleBird(initialWidth, initialHeight);
	}
	
	/**
	 * Method to scale the bird sprite into the desired dimensions
	 * @param width The desired width of the flappy bird
	 * @param height The desired height of the flappy bird
	 */
	public void scaleBird(int width, int height) {
		flappyBird = flappyBird.getScaledInstance(width, height, Image.SCALE_SMOOTH);		
	}
	
	/**
	 * Getter method for the flappyBird object.
	 * @return Image
	 */
	public Image getBird() {
		return flappyBird;
	}
	
	/**
	 * Method to obtain the width of the Bird object
	 * @return int
	 */
	public int getWidth() {
		try {
			return flappyBird.getWidth(null);
		}
		catch(Exception e) {
			return -1;
		}
	}
	
	/**
	 * Method to obtain the height of the Bird object
	 * @return int
	 */
	public int getHeight() {
		try {
			return flappyBird.getHeight(null);
		}
		catch(Exception e) {
			return -1;
		}
	}
	
	/**
	 * Method to set the x location of the Bird object
	 * @param x
	 */
	public void setX(int x) {
		xLoc = x;
	}
	
	/**
	 * Method to get the x location of the Bird object
	 * @return int
	 */
	public int getX() {
		return xLoc;
	}
	
	/**
	 * Method to set the y location of the Bird object
	 * @param y
	 */
	public void setY(int y) {
		yLoc = y;
	}
	
	/**
	 * Method to get the y location of the Bird object
	 * @return int
	 */
	public int getY() {
		return yLoc;
	}
	
	/**
	 * Method used to acquire a Rectangle that outlines the Bird's image
	 * @return Rectangle outlining the bird's position on screen
	 */
	public Rectangle getRectangle() {
		return (new Rectangle(xLoc, yLoc, flappyBird.getWidth(null), flappyBird.getHeight(null)));
	}
	
	/**
	 * Method to acquire a BufferedImage that represents the Bird's image object
	 * @return Bird's BufferedImage object
	 */
	public BufferedImage getBI() {
		BufferedImage bi = new BufferedImage(flappyBird.getWidth(null), flappyBird.getHeight(null), BufferedImage.TYPE_INT_ARGB);
		Graphics g = bi.getGraphics();
		g.drawImage(flappyBird, 0, 0, null);
		g.dispose();
		return bi;
	}
}

import java.awt.Graphics;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.awt.Image;
import java.awt.image.BufferedImage;

public class BottomPipe {
	//global variables
	private Image bottomPipe;
	private int xLoc = 0, yLoc = 0;
	
	/**
	 * Default constructor
	 */
	public BottomPipe(int initialWidth, int initialHeight) {
		bottomPipe = Toolkit.getDefaultToolkit().getImage(this.getClass().getResource("resources/tube_bottom.png"));
		scaleBottomPipe(initialWidth, initialHeight);
	}
	
	/**
	 * Method to scale the BottomPipe sprite into the desired dimensions
	 * @param width The desired width of the BottomPipe
	 * @param height The desired height of the BottomPipe
	 */
	public void scaleBottomPipe(int width, int height) {
		bottomPipe = bottomPipe.getScaledInstance(width, height, Image.SCALE_SMOOTH);		
	}
	
	/**
	 * Getter method for the BottomPipe object.
	 * @return Image
	 */
	public Image getPipe() {
		return bottomPipe;
	}
	
	/**
	 * Method to obtain the width of the BottomPipe object
	 * @return int
	 */
	public int getWidth() {
		return bottomPipe.getWidth(null);
	}
	
	/**
	 * Method to obtain the height of the BottomPipe object
	 * @return int
	 */
	public int getHeight() {
		return bottomPipe.getHeight(null);
	}
	
	/**
	 * Method to set the x location of the BottomPipe object
	 * @param x
	 */
	public void setX(int x) {
		xLoc = x;
	}
	
	/**
	 * Method to get the x location of the BottomPipe object
	 * @return int
	 */
	public int getX() {
		return xLoc;
	}
	
	/**
	 * Method to set the y location of the BottomPipe object
	 * @param y
	 */
	public void setY(int y) {
		yLoc = y;
	}
	
	/**
	 * Method to get the y location of the BottomPipe object
	 * @return int
	 */
	public int getY() {
		return yLoc;
	}
	
	/**
	 * Method used to acquire a Rectangle that outlines the BottomPipe's image
	 * @return Rectangle outlining the BottomPipe's position on screen
	 */
	public Rectangle getRectangle() {
		return (new Rectangle(xLoc, yLoc, bottomPipe.getWidth(null), bottomPipe.getHeight(null)));
	}
	
	/**
	 * Method to acquire a BufferedImage that represents the TopPipe's image object
	 * @return TopPipe's BufferedImage object
	 */
	public BufferedImage getBI() {
		BufferedImage bi = new BufferedImage(bottomPipe.getWidth(null), bottomPipe.getHeight(null), BufferedImage.TYPE_INT_ARGB);
		Graphics g = bi.getGraphics();
		g.drawImage(bottomPipe, 0, 0, null);
		g.dispose();
		return bi;
	}
}

import java.awt.Graphics;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.awt.Image;
import java.awt.image.BufferedImage;

public class TopPipe {
	//global variables
	private Image topPipe;
	private int xLoc = 0, yLoc = 0;

	/**
	 * Default constructor
	 */
	public TopPipe(int initialWidth, int initialHeight) {
		topPipe = Toolkit.getDefaultToolkit().getImage(this.getClass().getResource("resources/tube_top.png"));
		scaleTopPipe(initialWidth, initialHeight);
	}

	/**
	 * Method to scale the topPipe sprite into the desired dimensions
	 * @param width The desired width of the topPipe
	 * @param height The desired height of the topPipe
	 */
	public void scaleTopPipe(int width, int height) {
		topPipe = topPipe.getScaledInstance(width, height, Image.SCALE_SMOOTH);		
	}

	/**
	 * Getter method for the TopPipe object.
	 * @return Image
	 */
	public Image getPipe() {
		return topPipe;
	}

	/**
	 * Method to obtain the width of the TopPipe object
	 * @return int
	 */
	public int getWidth() {
		return topPipe.getWidth(null);
	}

	/**
	 * Method to obtain the height of the TopPipe object
	 * @return int
	 */
	public int getHeight() {
		return topPipe.getHeight(null);
	}

	/**
	 * Method to set the x location of the TopPipe object
	 * @param x
	 */
	public void setX(int x) {
		xLoc = x;
	}

	/**
	 * Method to get the x location of the TopPipe object
	 * @return int
	 */
	public int getX() {
		return xLoc;
	}

	/**
	 * Method to set the y location of the TopPipe object
	 * @param y
	 */
	public void setY(int y) {
		yLoc = y;
	}

	/**
	 * Method to get the y location of the TopPipe object
	 * @return int
	 */
	public int getY() {
		return yLoc;
	}

	/**
	 * Method used to acquire a Rectangle that outlines the TopPipe's image
	 * @return Rectangle outlining the TopPipe's position on screen
	 */
	public Rectangle getRectangle() {
		return (new Rectangle(xLoc, yLoc, topPipe.getWidth(null), topPipe.getHeight(null)));
	}
	
	/**
	 * Method to acquire a BufferedImage that represents the TopPipe's image object
	 * @return TopPipe's BufferedImage object
	 */
	public BufferedImage getBI() {
		BufferedImage bi = new BufferedImage(topPipe.getWidth(null), topPipe.getHeight(null), BufferedImage.TYPE_INT_ARGB);
		Graphics g = bi.getGraphics();
		g.drawImage(topPipe, 0, 0, null);
		g.dispose();
		return bi;
	}
}

import javax.swing.*;
import java.awt.Graphics;

public class PlayGameScreen extends JPanel {
	//global variables
	private int screenWidth, screenHeight;
	private boolean isSplash = true;
	/**
	 * Default constructor for the PlayGameScreen class
	 */
	public PlayGameScreen(int screenWidth, int screenHeight, boolean isSplash) {
		this.screenWidth = screenWidth;
		this.screenHeight = screenHeight;
		this.isSplash = isSplash;
	}
	
	/**
	 * Manually control what's drawn on this JPanel by calling the paintComponent method
	 * with a graphics object and painting using that object
	 */
	public void paintComponent(Graphics g) {
		super.paintComponent(g);
		//perform drawing operations
	}
}

import java.awt.Dimension;
import java.awt.Font;
import java.awt.Image;
import java.awt.Color;
import java.awt.LayoutManager;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.*;

public class TopClass implements ActionListener {
	//global constant variables
	private static final int SCREEN_WIDTH = (int) Toolkit.getDefaultToolkit().getScreenSize().getWidth();
	private static final int SCREEN_HEIGHT = (int) Toolkit.getDefaultToolkit().getScreenSize().getHeight();
	
	//global variables
	
	//global swing objects
	private JFrame f = new JFrame("Flappy Bird Redux");
	private JButton startGame;
	private JPanel topPanel; //declared globally to accommodate the repaint operation and allow for removeAll(), etc.
	
	//other global objects
	private static TopClass tc = new TopClass();
	private static PlayGameScreen pgs; //panel that has the moving background at the start of the game
	
	/**
	 * Default constructor
	 */
	public TopClass() {
	}
	
	/**
	 * Main executable method invoked when running .jar file
	 * @param args
	 */
	public static void main(String[] args) {
		//build the GUI on a new thread
		
		javax.swing.SwingUtilities.invokeLater(new Runnable() {
			public void run() {
				tc.buildFrame();
				
				//create a new thread to keep the GUI responsive while the game runs
				Thread t = new Thread() {
					public void run() {
						//run the game here
					}
				};
				t.start();
			}
		});
	}
	
	/**
	 * Method to construct the JFrame and add the program content
	 */
	private void buildFrame() {
		Image icon = Toolkit.getDefaultToolkit().getImage(this.getClass().getResource("resources/blue_bird.png"));
		f.setContentPane(createContentPane());
        	f.setResizable(true);
	        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	        f.setAlwaysOnTop(false);
	        f.setVisible(true);
	        f.setMinimumSize(new Dimension(SCREEN_WIDTH*1/4, SCREEN_HEIGHT*1/4));
	        f.setExtendedState(JFrame.MAXIMIZED_BOTH);
	        f.setIconImage(icon);
	        f.addKeyListener(this);
	}
	
	private JPanel createContentPane() {
		topPanel = new JPanel(); //top-most JPanel in layout hierarchy
		topPanel.setBackground(Color.BLACK);
		
		//allow us to layer the panels:
		LayoutManager overlay = new OverlayLayout(topPanel);
		topPanel.setLayout(overlay);
		
		//Start Game JButton
		startGame = new JButton("Start Playing!");
		startGame.setBackground(Color.BLUE);
		startGame.setForeground(Color.WHITE);
		startGame.setFocusable(false);
		startGame.setFont(new Font("Calibri", Font.BOLD, 42));
		startGame.setAlignmentX(0.5f); //center horizontally on-screen
		startGame.setAlignmentY(0.5f); //center vertically on-screen
		startGame.addActionListener(this);
		topPanel.add(startGame);
		
		//must add last to ensure button's visibility
		pgs = new PlayGameScreen(SCREEN_WIDTH, SCREEN_HEIGHT, true); //true --> we want pgs to be the splash screen
		topPanel.add(pgs);
		
		return topPanel;
	}
	
	/**
	 * Implementation for action events
	 */
	public void actionPerformed(ActionEvent e) {
		if(e.getSource() == startGame) {
			//do something
		}
	}
}

import java.awt.Dimension;
import java.awt.Font;
import java.awt.Image;
import java.awt.Color;
import java.awt.LayoutManager;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.*;

public class TopClass implements ActionListener {
	//global constant variables
	private static final int SCREEN_WIDTH = (int) Toolkit.getDefaultToolkit().getScreenSize().getWidth();
	private static final int SCREEN_HEIGHT = (int) Toolkit.getDefaultToolkit().getScreenSize().getHeight();
	private static final int PIPE_GAP = SCREEN_HEIGHT/5; //distance in pixels between pipes
	private static final int PIPE_WIDTH = SCREEN_WIDTH/8, PIPE_HEIGHT = 4*PIPE_WIDTH;
	private static final int UPDATE_DIFFERENCE = 25; //time in ms between updates
	private static final int X_MOVEMENT_DIFFERENCE = 5; //distance the pipes move every update
	private static final int SCREEN_DELAY = 300; //needed because of long load times forcing pipes to pop up mid-screen
	
	//global variables
	private boolean loopVar = true; //false -> don't run loop; true -> run loop for pipes
	
	//global swing objects
	private JFrame f = new JFrame("Flappy Bird Redux");
	private JButton startGame;
	private JPanel topPanel; //declared globally to accommodate the repaint operation and allow for removeAll(), etc.
	
	//other global objects
	private static TopClass tc = new TopClass();
	private static PlayGameScreen pgs; //panel that has the moving background at the start of the game
	
	/**
	 * Default constructor
	 */
	public TopClass() {
		
	}
	
	/**
	 * Main executable method invoked when running .jar file
	 * @param args
	 */
	public static void main(String[] args) {
		//build the GUI on a new thread
		
		javax.swing.SwingUtilities.invokeLater(new Runnable() {
			public void run() {
				tc.buildFrame();
				
				//create a new thread to keep the GUI responsive while the game runs
				Thread t = new Thread() {
					public void run() {
						tc.gameScreen(true);
					}
				};
				t.start();
			}
		});
	}
	
	/**
	 * Method to construct the JFrame and add the program content
	 */
	private void buildFrame() {
		Image icon = Toolkit.getDefaultToolkit().getImage(this.getClass().getResource("resources/blue_bird.png"));
		f.setContentPane(createContentPane());
                f.setResizable(true);
                f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                f.setAlwaysOnTop(false);
                f.setVisible(true);
                f.setMinimumSize(new Dimension(SCREEN_WIDTH*1/4, SCREEN_HEIGHT*1/4));
                f.setExtendedState(JFrame.MAXIMIZED_BOTH);
                f.setIconImage(icon);
                f.addKeyListener(this);
	}
	
	private JPanel createContentPane() {
		topPanel = new JPanel(); //top-most JPanel in layout hierarchy
		topPanel.setBackground(Color.BLACK);
		//allow us to layer the panels
		LayoutManager overlay = new OverlayLayout(topPanel);
		topPanel.setLayout(overlay);
		
		//Start Game JButton
		startGame = new JButton("Start Playing!");
		startGame.setBackground(Color.BLUE);
		startGame.setForeground(Color.WHITE);
		startGame.setFocusable(false); //rather than just setFocusabled(false)
		startGame.setFont(new Font("Calibri", Font.BOLD, 42));
		startGame.setAlignmentX(0.5f); //center horizontally on-screen
		startGame.setAlignmentY(0.5f); //center vertically on-screen
		startGame.addActionListener(this);
		topPanel.add(startGame);
		
		//must add last to ensure button's visibility
		pgs = new PlayGameScreen(SCREEN_WIDTH, SCREEN_HEIGHT, true); //true --> we want pgs to be the splash screen
		topPanel.add(pgs);
		
		return topPanel;
	}
	
	/**
	 * Implementation for action events
	 */
	public void actionPerformed(ActionEvent e) {
		if(e.getSource() == startGame) {
			//do something
		}
	}
	
	/**
	 * Method that performs the splash screen graphics movements
	 */
	private void gameScreen(boolean isSplash) {
		BottomPipe bp1 = new BottomPipe(PIPE_WIDTH, PIPE_HEIGHT);
		BottomPipe bp2 = new BottomPipe(PIPE_WIDTH, PIPE_HEIGHT);
		TopPipe tp1 = new TopPipe(PIPE_WIDTH, PIPE_HEIGHT);
		TopPipe tp2 = new TopPipe(PIPE_WIDTH, PIPE_HEIGHT);
		
		//variables to track x and y image locations for the bottom pipe
		int xLoc1 = SCREEN_WIDTH+SCREEN_DELAY, xLoc2 = (int) ((double) 3.0/2.0*SCREEN_WIDTH+PIPE_WIDTH/2.0)+SCREEN_DELAY;
		int yLoc1 = bottomPipeLoc(), yLoc2 = bottomPipeLoc();
		
		//variable to hold the loop start time
		long startTime = System.currentTimeMillis();
		
		while(loopVar) {
			if((System.currentTimeMillis() - startTime) > UPDATE_DIFFERENCE) {
				//check if a set of pipes has left the screen
				//if so, reset the pipe's X location and assign a new Y location
				if(xLoc1 < (0-PIPE_WIDTH)) {
					xLoc1 = SCREEN_WIDTH;
					yLoc1 = bottomPipeLoc();
				}
				else if(xLoc2 < (0-PIPE_WIDTH)) {
					xLoc2 = SCREEN_WIDTH;
					yLoc2 = bottomPipeLoc();
				}
				
				//decrement the pipe locations by the predetermined amount 
				xLoc1 -= X_MOVEMENT_DIFFERENCE;
				xLoc2 -= X_MOVEMENT_DIFFERENCE;
				
				//update the BottomPipe and TopPipe locations
				bp1.setX(xLoc1);
				bp1.setY(yLoc1);
				bp2.setX(xLoc2);
				bp2.setY(yLoc2);
				tp1.setX(xLoc1);
				tp1.setY(yLoc1-PIPE_GAP-PIPE_HEIGHT); //ensure tp1 placed in proper location
				tp2.setX(xLoc2);
				tp2.setY(yLoc2-PIPE_GAP-PIPE_HEIGHT); //ensure tp2 placed in proper location
				
				//set the BottomPipe and TopPipe local variables in PlayGameScreen by parsing the local variables
				pgs.setBottomPipe(bp1, bp2);
				pgs.setTopPipe(tp1, tp2);
				
				//update pgs's JPanel
				topPanel.revalidate();
				topPanel.repaint();
				
				//update the time-tracking variable after all operations completed
				startTime = System.currentTimeMillis();
			}
		}
	}
	
	/**
	 * Calculates a random int for the bottom pipe's placement
	 * @return int
	 */
	private int bottomPipeLoc() {
		int temp = 0;
		//iterate until temp is a value that allows both pipes to be onscreen
		while(temp <= PIPE_GAP+50 || temp >= SCREEN_HEIGHT-PIPE_GAP) {
			temp = (int) ((double) Math.random()*((double)SCREEN_HEIGHT));
		}
		return temp;
	}
}

import javax.swing.*;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Color;

public class PlayGameScreen extends JPanel {
	//default reference ID
	private static final long serialVersionUID = 1L;
	
	//global variables
	private int screenWidth, screenHeight;
	private boolean isSplash = true;
	private String message = "Flappy Bird";
	private Font primaryFont = new Font("Goudy Stout", Font.BOLD, 56), failFont = new Font("Calibri", Font.BOLD, 56);
	private int messageWidth = 0;
	private BottomPipe bp1, bp2;
	private TopPipe tp1, tp2;

	/**
	 * Default constructor for the PlayGameScreen class
	 */
	public PlayGameScreen(int screenWidth, int screenHeight, boolean isSplash) {
		this.screenWidth = screenWidth;
		this.screenHeight = screenHeight;
		this.isSplash = isSplash;
	}
	
	/**
	 * Manually control what's drawn on this JPanel by calling the paintComponent method
	 * with a graphics object and painting using that object
	 */
	public void paintComponent(Graphics g) {
		super.paintComponent(g);
		
		g.setColor(new Color(89, 81, 247)); //color for the blue sky
		g.fillRect(0, 0, screenWidth, screenHeight*7/8); //create the sky rectangle
		g.setColor(new Color(147, 136, 9)); //brown color for ground
		g.fillRect(0, screenHeight*7/8, screenWidth, screenHeight/8); //create the ground rectangle
		g.setColor(Color.BLACK); //dividing line color
		g.drawLine(0, screenHeight*7/8, screenWidth, screenHeight*7/8); //draw the dividing line
		
		//objects must be instantiated before they're drawn!
		if(bp1 != null && bp2 != null && tp1 != null && tp2 != null) {
			g.drawImage(bp1.getPipe(), bp1.getX(), bp1.getY(), null);
			g.drawImage(bp2.getPipe(), bp2.getX(), bp2.getY(), null);
			g.drawImage(tp1.getPipe(), tp1.getX(), tp1.getY(), null);
			g.drawImage(tp2.getPipe(), tp2.getX(), tp2.getY(), null);
		}
		
		//needed in case the primary font does not exist
		try {
			g.setFont(primaryFont);
			FontMetrics metric = g.getFontMetrics(primaryFont);
			messageWidth = metric.stringWidth(message);
		}
		catch(Exception e) {
			g.setFont(failFont);
			FontMetrics metric = g.getFontMetrics(failFont);
			messageWidth = metric.stringWidth(message);
		}
		g.drawString(message, screenWidth/2-messageWidth/2, screenHeight/4);
	}
	
	/**
	 * Parsing method for PlayGameScreen's global BottomPipe variables
	 * @param bp1 The first BottomPipe
	 * @param bp2 The second BottomPipe
	 */
	public void setBottomPipe(BottomPipe bp1, BottomPipe bp2) {
		this.bp1 = bp1;
		this.bp2 = bp2;
	}
	
	/**
	 * Parsing method for PlayGameScreen's global TopPipe variables
	 * @param tp1 The first TopPipe
	 * @param tp2 The second TopPipe
	 */
	public void setTopPipe(TopPipe tp1, TopPipe tp2) {
		this.tp1 = tp1;
		this.tp2 = tp2;
	}
	
	/**
	 * Method called to parse a message onto the screen
	 * @param message The message to parse
	 */
	public void sendText(String message) {
		this.message = message;
	}
}

import java.awt.Dimension;
import java.awt.Font;
import java.awt.Image;
import java.awt.Color;
import java.awt.LayoutManager;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.*;

public class TopClass implements ActionListener {
	//global constant variables
	private static final int SCREEN_WIDTH = (int) Toolkit.getDefaultToolkit().getScreenSize().getWidth();
	private static final int SCREEN_HEIGHT = (int) Toolkit.getDefaultToolkit().getScreenSize().getHeight();
	private static final int PIPE_GAP = SCREEN_HEIGHT/5; //distance in pixels between pipes
	private static final int PIPE_WIDTH = SCREEN_WIDTH/8, PIPE_HEIGHT = 4*PIPE_WIDTH;
	private static final int UPDATE_DIFFERENCE = 25; //time in ms between updates
	private static final int X_MOVEMENT_DIFFERENCE = 5; //distance the pipes move every update
	private static final int SCREEN_DELAY = 300; //needed because of long load times forcing pipes to pop up mid-screen
	
	//global variables
	private boolean loopVar = true; //false -> don't run loop; true -> run loop for pipes
	private Object buildComplete = new Object();
	
	//global swing objects
	private JFrame f = new JFrame("Flappy Bird Redux");
	private JButton startGame;
	private JPanel topPanel; //declared globally to accommodate the repaint operation and allow for removeAll(), etc.
	
	//other global objects
	private static TopClass tc = new TopClass();
	private static PlayGameScreen pgs; //panel that has the moving background at the start of the game
	
	/**
	 * Default constructor
	 */
	public TopClass() {
		
	}
	
	/**
	 * Main executable method invoked when running .jar file
	 * @param args
	 */
	public static void main(String[] args) {
		//build the GUI on a new thread
		
		javax.swing.SwingUtilities.invokeLater(new Runnable() {
			public void run() {
				tc.buildFrame();
				
				//create a new thread to keep the GUI responsive while the game runs
				Thread t = new Thread() {
					public void run() {
						tc.gameScreen(true);
					}
				};
				t.start();
			}
		});
	}
	
	/**
	 * Method to construct the JFrame and add the program content
	 */
	private void buildFrame() {
		Image icon = Toolkit.getDefaultToolkit().getImage(this.getClass().getResource("resources/blue_bird.png"));
		f.setContentPane(createContentPane());
        	f.setResizable(true);
	        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	        f.setAlwaysOnTop(false);
	        f.setVisible(true);
	        f.setMinimumSize(new Dimension(SCREEN_WIDTH*1/4, SCREEN_HEIGHT*1/4));
	        f.setExtendedState(JFrame.MAXIMIZED_BOTH);
	        f.setIconImage(icon);
	        f.addKeyListener(this);
	}
	
	private JPanel createContentPane() {
		topPanel = new JPanel(); //top-most JPanel in layout hierarchy
		topPanel.setBackground(Color.BLACK);
		//allow us to layer the panels
		LayoutManager overlay = new OverlayLayout(topPanel);
		topPanel.setLayout(overlay);
		
		//Start Game JButton
		startGame = new JButton("Start Playing!");
		startGame.setBackground(Color.BLUE);
		startGame.setForeground(Color.WHITE);
		startGame.setFocusable(false); //rather than just setFocusabled(false)
		startGame.setFont(new Font("Calibri", Font.BOLD, 42));
		startGame.setAlignmentX(0.5f); //center horizontally on-screen
		startGame.setAlignmentY(0.5f); //center vertically on-screen
		startGame.addActionListener(this);
		topPanel.add(startGame);
		
		//must add last to ensure button's visibility
		pgs = new PlayGameScreen(SCREEN_WIDTH, SCREEN_HEIGHT, true); //true --> we want pgs to be the splash screen
		topPanel.add(pgs);
		
		return topPanel;
	}
	
	/**
	 * Implementation for action events
	 */
	public void actionPerformed(ActionEvent e) {
		if(e.getSource() == startGame) {
			//stop the splash screen
			loopVar = false;
			
			fadeOperation();
		}
		else if(e.getSource() == buildComplete) {
			Thread t = new Thread() {
				public void run() {
					loopVar = true;
					tc.gameScreen(false);
				}
			};
			t.start();
		}
	}
	
	/** 
	 * Perform the fade operation that takes place before the start of rounds
	 */
	private void fadeOperation() {
		Thread t = new Thread() {
			public void run() {
				topPanel.remove(startGame);
				topPanel.remove(pgs);
				topPanel.revalidate();
				topPanel.repaint();
				
				//panel to fade
				JPanel temp = new JPanel();
				int alpha = 0; //alpha channel variable
				temp.setBackground(new Color(0, 0, 0, alpha)); //transparent, black JPanel
				topPanel.add(temp);
				topPanel.add(pgs);
				topPanel.revalidate();
				topPanel.repaint();
				
				long currentTime = System.currentTimeMillis();
				long startTime = currentTime;
				
				while((System.currentTimeMillis() - startTime) > FADE_TIME_MILLIS || temp.getBackground().getAlpha() != 255) {
					if((System.currentTimeMillis() - startTime) > UPDATE_DIFFERENCE/2) {
						if(alpha < 255 - 10) {
							alpha += 10;
						}
						else {
							alpha = 255;
						}
						
						temp.setBackground(new Color(0, 0, 0, alpha));
					
						topPanel.revalidate();
						topPanel.repaint();
						startTime = System.currentTimeMillis();
					}
				}
				
				topPanel.removeAll();
				topPanel.add(temp);
				pgs = new PlayGameScreen(SCREEN_WIDTH, SCREEN_HEIGHT, false);
				pgs.sendText(""); //remove title text
				topPanel.add(pgs);
				
				while((System.currentTimeMillis() - startTime) > FADE_TIME_MILLIS || temp.getBackground().getAlpha() != 0) {
					if((System.currentTimeMillis() - startTime) > UPDATE_DIFFERENCE/2) {
						if(alpha > 10) {
							alpha -= 10;
						}
						else {
							alpha = 0;
						}
						
						temp.setBackground(new Color(0, 0, 0, alpha));
					
						topPanel.revalidate();
						topPanel.repaint();
						startTime = System.currentTimeMillis();
					}
				}
				
				actionPerformed(new ActionEvent(buildComplete, -1, "Build Finished"));
			}
		};
		
		t.start();
	}
	
	/**
	 * Method that performs the splash screen graphics movements
	 */
	private void gameScreen(boolean isSplash) {
		BottomPipe bp1 = new BottomPipe(PIPE_WIDTH, PIPE_HEIGHT);
		BottomPipe bp2 = new BottomPipe(PIPE_WIDTH, PIPE_HEIGHT);
		TopPipe tp1 = new TopPipe(PIPE_WIDTH, PIPE_HEIGHT);
		TopPipe tp2 = new TopPipe(PIPE_WIDTH, PIPE_HEIGHT);
		
		//variables to track x and y image locations for the bottom pipe
		int xLoc1 = SCREEN_WIDTH+SCREEN_DELAY, xLoc2 = (int) ((double) 3.0/2.0*SCREEN_WIDTH+PIPE_WIDTH/2.0)+SCREEN_DELAY;
		int yLoc1 = bottomPipeLoc(), yLoc2 = bottomPipeLoc();
		
		//variable to hold the loop start time
		long startTime = System.currentTimeMillis();
		
		while(loopVar) {
			if((System.currentTimeMillis() - startTime) > UPDATE_DIFFERENCE) {
				//check if a set of pipes has left the screen
				//if so, reset the pipe's X location and assign a new Y location
				if(xLoc1 < (0-PIPE_WIDTH)) {
					xLoc1 = SCREEN_WIDTH;
					yLoc1 = bottomPipeLoc();
				}
				else if(xLoc2 < (0-PIPE_WIDTH)) {
					xLoc2 = SCREEN_WIDTH;
					yLoc2 = bottomPipeLoc();
				}
				
				//decrement the pipe locations by the predetermined amount
				xLoc1 -= X_MOVEMENT_DIFFERENCE;
				xLoc2 -= X_MOVEMENT_DIFFERENCE;
				
				//update the BottomPipe and TopPipe locations
				bp1.setX(xLoc1);
				bp1.setY(yLoc1);
				bp2.setX(xLoc2);
				bp2.setY(yLoc2);
				tp1.setX(xLoc1);
				tp1.setY(yLoc1-PIPE_GAP-PIPE_HEIGHT); //ensure tp1 placed in proper location
				tp2.setX(xLoc2);
				tp2.setY(yLoc2-PIPE_GAP-PIPE_HEIGHT); //ensure tp2 placed in proper location
				
				//set the BottomPipe and TopPipe local variables in PlayGameScreen by parsing the local variables
				pgs.setBottomPipe(bp1, bp2);
				pgs.setTopPipe(tp1, tp2);
				
				//update pgs's JPanel
				topPanel.revalidate();
				topPanel.repaint();
				
				//update the time-tracking variable after all operations completed
				startTime = System.currentTimeMillis();
			}
		}
	}
	
	/**
	 * Calculates a random int for the bottom pipe's placement
	 * @return int
	 */
	private int bottomPipeLoc() {
		int temp = 0;
		//iterate until temp is a value that allows both pipes to be onscreen
		while(temp <= PIPE_GAP+50 || temp >= SCREEN_HEIGHT-PIPE_GAP) {
			temp = (int) ((double) Math.random()*((double)SCREEN_HEIGHT));
		}
		return temp;
	}
}

import java.awt.Dimension;
import java.awt.Font;
import java.awt.Image;
import java.awt.Color;
import java.awt.LayoutManager;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import javax.swing.*;

public class TopClass implements ActionListener, KeyListener {
	//global constant variables
	private static final int SCREEN_WIDTH = (int) Toolkit.getDefaultToolkit().getScreenSize().getWidth();
	private static final int SCREEN_HEIGHT = (int) Toolkit.getDefaultToolkit().getScreenSize().getHeight();
	private static final int PIPE_GAP = SCREEN_HEIGHT/5; //distance in pixels between pipes
	private static final int PIPE_WIDTH = SCREEN_WIDTH/8, PIPE_HEIGHT = 4*PIPE_WIDTH;
	private static final int BIRD_WIDTH = 120, BIRD_HEIGHT = 75;
	private static final int UPDATE_DIFFERENCE = 25; //time in ms between updates
	private static final int X_MOVEMENT_DIFFERENCE = 5; //distance the pipes move every update
	private static final int SCREEN_DELAY = 300; //needed because of long load times forcing pipes to pop up mid-screen
	private static final int BIRD_X_LOCATION = SCREEN_WIDTH/7;
	private static final int BIRD_JUMP_DIFF = 10, BIRD_FALL_DIFF = BIRD_JUMP_DIFF/2, BIRD_JUMP_HEIGHT = PIPE_GAP - BIRD_HEIGHT - BIRD_JUMP_DIFF*2;
	
	//global variables
	private boolean loopVar = true; //false -> don't run loop; true -> run loop for pipes
	private boolean gamePlay = false; //false -> game not being played
	private boolean birdThrust = false; //false -> key has not been pressed to move the bird vertically
	private boolean birdFired = false; //true -> button pressed before jump completes
	private boolean released = true; //space bar released; starts as true so first press registers
	private int birdYTracker = SCREEN_HEIGHT/2 - BIRD_HEIGHT;
	private Object buildComplete = new Object();
	
	//global swing objects
	private JFrame f = new JFrame("Flappy Bird Redux");
	private JButton startGame;
	private JPanel topPanel; //declared globally to accommodate the repaint operation and allow for removeAll(), etc.
	
	//other global objects
	private static TopClass tc = new TopClass();
	private static PlayGameScreen pgs; //panel that has the moving background at the start of the game
	
	/**
	 * Default constructor
	 */
	public TopClass() {
		
	}
	
	/**
	 * Main executable method invoked when running .jar file
	 * @param args
	 */
	public static void main(String[] args) {
		//build the GUI on a new thread
		
		javax.swing.SwingUtilities.invokeLater(new Runnable() {
			public void run() {
				tc.buildFrame();
				
				//create a new thread to keep the GUI responsive while the game runs
				Thread t = new Thread() {
					public void run() {
						tc.gameScreen(true);
					}
				};
				t.start();
			}
		});
	}
	
	/**
	 * Method to construct the JFrame and add the program content
	 */
	private void buildFrame() {
		Image icon = Toolkit.getDefaultToolkit().getImage(this.getClass().getResource("resources/blue_bird.png"));
		f.setContentPane(createContentPane());
	        f.setResizable(true);
	        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	        f.setAlwaysOnTop(false);
	        f.setVisible(true);
	        f.setMinimumSize(new Dimension(SCREEN_WIDTH*1/4, SCREEN_HEIGHT*1/4));
	        f.setExtendedState(JFrame.MAXIMIZED_BOTH);
	        f.setIconImage(icon);
	        f.addKeyListener(this);
	}
	
	private JPanel createContentPane() {
		topPanel = new JPanel(); //top-most JPanel in layout hierarchy
		topPanel.setBackground(Color.BLACK);
		//allow us to layer the panels
		LayoutManager overlay = new OverlayLayout(topPanel);
		topPanel.setLayout(overlay);
		
		//Start Game JButton
		startGame = new JButton("Start Playing!");
		startGame.setBackground(Color.BLUE);
		startGame.setForeground(Color.WHITE);
		startGame.setFocusable(false); //rather than just setFocusabled(false)
		startGame.setFont(new Font("Calibri", Font.BOLD, 42));
		startGame.setAlignmentX(0.5f); //center horizontally on-screen
		startGame.setAlignmentY(0.5f); //center vertically on-screen
		startGame.addActionListener(this);
		topPanel.add(startGame);
		
		//must add last to ensure button's visibility
		pgs = new PlayGameScreen(SCREEN_WIDTH, SCREEN_HEIGHT, true); //true --> we want pgs to be the splash screen
		topPanel.add(pgs);
		
		return topPanel;
	}
	
	/**
	 * Implementation for action events
	 */
	public void actionPerformed(ActionEvent e) {
		if(e.getSource() == startGame) {
			//stop the splash screen
			loopVar = false;
			
			fadeOperation();
		}
		else if(e.getSource() == buildComplete) {
			Thread t = new Thread() {
				public void run() {
					loopVar = true;
					gamePlay = true;
					tc.gameScreen(false);
				}
			};
			t.start();
		}
	}
	
	public void keyPressed(KeyEvent e) {
		if(e.getKeyCode() == KeyEvent.VK_SPACE && gamePlay == true && released == true){
			//update a boolean that's tested in game loop to move the bird
			if(birdThrust) { //need this to register the button press and reset the birdYTracker before the jump operation completes
				birdFired = true;
			}
			birdThrust = true;
			released = false;
		}
		else if(e.getKeyCode() == KeyEvent.VK_B && gamePlay == false) {
			birdYTracker = SCREEN_HEIGHT/2 - BIRD_HEIGHT; //need to reset the bird's starting height
			birdThrust = false; //if user presses SPACE before collision and a collision occurs before reaching max height, you get residual jump, so this is preventative
			actionPerformed(new ActionEvent(startGame, -1, ""));
		}
		if(e.getKeyCode() == KeyEvent.VK_ESCAPE) {
			System.exit(0);
		}
	}
	
	public void keyReleased(KeyEvent e) {
		if(e.getKeyCode() == KeyEvent.VK_SPACE) {
			released = true;
		}
	}
	
	public void keyTyped(KeyEvent e) {
		
	}
	
	/**
	 * Perform the fade operation that take place before the start of rounds
	 */
	private void fadeOperation() {
		Thread t = new Thread() {
			public void run() {
				topPanel.remove(startGame);
				topPanel.remove(pgs);
				topPanel.revalidate();
				topPanel.repaint();
				
				//panel to fade
				JPanel temp = new JPanel();
				int alpha = 0; //alpha channel variable
				temp.setBackground(new Color(0, 0, 0, alpha)); //transparent, black JPanel
				topPanel.add(temp);
				topPanel.add(pgs);
				topPanel.revalidate();
				topPanel.repaint();
				
				long currentTime = System.currentTimeMillis();
				
				while(temp.getBackground().getAlpha() != 255) {
					if((System.currentTimeMillis() - currentTime) > UPDATE_DIFFERENCE/2) {
						if(alpha < 255 - 10) {
							alpha += 10;
						}
						else {
							alpha = 255;
						}
						
						temp.setBackground(new Color(0, 0, 0, alpha));
					
						topPanel.revalidate();
						topPanel.repaint();
						currentTime = System.currentTimeMillis();
					}
				}
				
				topPanel.removeAll();
				topPanel.add(temp);
				pgs = new PlayGameScreen(SCREEN_WIDTH, SCREEN_HEIGHT, false);
				pgs.sendText(""); //remove title text
				topPanel.add(pgs);
				
				while(temp.getBackground().getAlpha() != 0) {
					if((System.currentTimeMillis() - currentTime) > UPDATE_DIFFERENCE/2) {
						if(alpha > 10) {
							alpha -= 10;
						}
						else {
							alpha = 0;
						}
						
						temp.setBackground(new Color(0, 0, 0, alpha));
					
						topPanel.revalidate();
						topPanel.repaint();
						currentTime = System.currentTimeMillis();
					}
				}
				
				actionPerformed(new ActionEvent(buildComplete, -1, "Build Finished"));
			}
		};
		
		t.start();
	}
	
	/**
	 * Method that performs the splash screen graphics movements
	 */
	private void gameScreen(boolean isSplash) {
		BottomPipe bp1 = new BottomPipe(PIPE_WIDTH, PIPE_HEIGHT);
		BottomPipe bp2 = new BottomPipe(PIPE_WIDTH, PIPE_HEIGHT);
		TopPipe tp1 = new TopPipe(PIPE_WIDTH, PIPE_HEIGHT);
		TopPipe tp2 = new TopPipe(PIPE_WIDTH, PIPE_HEIGHT);
		Bird bird = new Bird(BIRD_WIDTH, BIRD_HEIGHT);
		
		//variables to track x and y image locations for the bottom pipe
		int xLoc1 = SCREEN_WIDTH+SCREEN_DELAY, xLoc2 = (int) ((double) 3.0/2.0*SCREEN_WIDTH+PIPE_WIDTH/2.0)+SCREEN_DELAY;
		int yLoc1 = bottomPipeLoc(), yLoc2 = bottomPipeLoc();
		int birdX = BIRD_X_LOCATION, birdY = birdYTracker;
		
		//variable to hold the loop start time
		long startTime = System.currentTimeMillis();
		
		while(loopVar) {
			if((System.currentTimeMillis() - startTime) > UPDATE_DIFFERENCE) {
				//check if a set of pipes has left the screen
				//if so, reset the pipe's X location and assign a new Y location
				if(xLoc1 < (0-PIPE_WIDTH)) {
					xLoc1 = SCREEN_WIDTH;
					yLoc1 = bottomPipeLoc();
				}
				else if(xLoc2 < (0-PIPE_WIDTH)) {
					xLoc2 = SCREEN_WIDTH;
					yLoc2 = bottomPipeLoc();
				}
				
				//decrement the pipe locations by the predetermined amount
				xLoc1 -= X_MOVEMENT_DIFFERENCE;
				xLoc2 -= X_MOVEMENT_DIFFERENCE;
				
				if(birdFired && !isSplash) {
					birdYTracker = birdY;
					birdFired = false;
				}
				
				if(birdThrust && !isSplash) {
					//move bird vertically
					if(birdYTracker - birdY - BIRD_JUMP_DIFF < BIRD_JUMP_HEIGHT) {
						if(birdY - BIRD_JUMP_DIFF > 0) {
							birdY -= BIRD_JUMP_DIFF; //coordinates different
						}
						else {
							birdY = 0;
							birdYTracker = birdY;
							birdThrust = false;
						}
					}
					else {
						birdYTracker = birdY;
						birdThrust = false;
					}
				}
				else if(!isSplash) {
					birdY += BIRD_FALL_DIFF;
					birdYTracker = birdY;
				}
				
				//update the BottomPipe and TopPipe locations
				bp1.setX(xLoc1);
				bp1.setY(yLoc1);
				bp2.setX(xLoc2);
				bp2.setY(yLoc2);
				tp1.setX(xLoc1);
				tp1.setY(yLoc1-PIPE_GAP-PIPE_HEIGHT); //ensure tp1 placed in proper location
				tp2.setX(xLoc2);
				tp2.setY(yLoc2-PIPE_GAP-PIPE_HEIGHT); //ensure tp2 placed in proper location
				
				if(!isSplash) {
					bird.setX(birdX);
					bird.setY(birdY);
					pgs.setBird(bird);
				}
				
				//set the BottomPipe and TopPipe local variables in PlayGameScreen by parsing the local variables
				pgs.setBottomPipe(bp1, bp2);
				pgs.setTopPipe(tp1, tp2);
				
				if(!isSplash && bird.getWidth() != -1) { //need the second part because if bird not on-screen, cannot get image width and have cascading error in collision
					updateScore(bp1, bp2, bird);
				}
				
				//update pgs's JPanel
				topPanel.revalidate();
				topPanel.repaint();
				
				//update the time-tracking variable after all operations completed
				startTime = System.currentTimeMillis();
			}
		}
	}
	
	/**
	 * Calculates a random int for the bottom pipe's placement
	 * @return int
	 */
	private int bottomPipeLoc() {
		int temp = 0;
		//iterate until temp is a value that allows both pipes to be onscreen
		while(temp <= PIPE_GAP+50 || temp >= SCREEN_HEIGHT-PIPE_GAP) {
			temp = (int) ((double) Math.random()*((double)SCREEN_HEIGHT));
		}
		return temp;
	}
	
	/**
	 * Method that checks whether the score needs to be updated
	 * @param bp1 First BottomPipe object
	 * @param bp2 Second BottomPipe object
	 * @param bird Bird object
	 */
	private void updateScore(BottomPipe bp1, BottomPipe bp2, Bird bird) {
		if(bp1.getX() + PIPE_WIDTH < bird.getX() && bp1.getX() + PIPE_WIDTH > bird.getX() - X_MOVEMENT_DIFFERENCE) {
			pgs.incrementJump();
		}
		else if(bp2.getX() + PIPE_WIDTH < bird.getX() && bp2.getX() + PIPE_WIDTH > bird.getX() - X_MOVEMENT_DIFFERENCE) {
			pgs.incrementJump();
		}
	}
}

import javax.swing.*;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Color;

public class PlayGameScreen extends JPanel {
	//default reference ID
	private static final long serialVersionUID = 1L;
	
	//global variables
	private int screenWidth, screenHeight;
	private boolean isSplash = true;
	private int successfulJumps = 0;
	private String message = "Flappy Bird";
	private Font primaryFont = new Font("Goudy Stout", Font.BOLD, 56), failFont = new Font("Calibri", Font.BOLD, 56);
	private int messageWidth = 0, scoreWidth = 0;
	private BottomPipe bp1, bp2;
	private TopPipe tp1, tp2;
	private Bird bird;</p><p>	/**
	 * Default constructor for the PlayGameScreen class
	 */
	public PlayGameScreen(int screenWidth, int screenHeight, boolean isSplash) {
		this.screenWidth = screenWidth;
		this.screenHeight = screenHeight;
		this.isSplash = isSplash;
	}
	
	/**
	 * Manually control what's drawn on this JPanel by calling the paintComponent method
	 * with a graphics object and painting using that object
	 */
	public void paintComponent(Graphics g) {
		super.paintComponent(g);
		
		g.setColor(new Color(89, 81, 247)); //color for the blue sky
		g.fillRect(0, 0, screenWidth, screenHeight*7/8); //create the sky rectangle
		g.setColor(new Color(147, 136, 9)); //brown color for ground
		g.fillRect(0, screenHeight*7/8, screenWidth, screenHeight/8); //create the ground rectangle
		g.setColor(Color.BLACK); //dividing line color
		g.drawLine(0, screenHeight*7/8, screenWidth, screenHeight*7/8); //draw the dividing line
		
		//objects must be instantiated before they're drawn!
		if(bp1 != null && bp2 != null && tp1 != null && tp2 != null) {
			g.drawImage(bp1.getPipe(), bp1.getX(), bp1.getY(), null);
			g.drawImage(bp2.getPipe(), bp2.getX(), bp2.getY(), null);
			g.drawImage(tp1.getPipe(), tp1.getX(), tp1.getY(), null);
			g.drawImage(tp2.getPipe(), tp2.getX(), tp2.getY(), null);
		}
		
		if(!isSplash && bird != null) {
			g.drawImage(bird.getBird(), bird.getX(), bird.getY(), null);
		}
		
		//needed in case the primary font does not exist
		try {
			g.setFont(primaryFont);
			FontMetrics metric = g.getFontMetrics(primaryFont);
			messageWidth = metric.stringWidth(message);
			scoreWidth = metric.stringWidth(String.format("%d", successfulJumps));
		}
		catch(Exception e) {
			g.setFont(failFont);
			FontMetrics metric = g.getFontMetrics(failFont);
			messageWidth = metric.stringWidth(message);
			scoreWidth = metric.stringWidth(String.format("%d", successfulJumps));
		}
		
		g.drawString(message, screenWidth/2-messageWidth/2, screenHeight/4);
		
		if(!isSplash) {
			g.drawString(String.format("%d", successfulJumps), screenWidth/2-scoreWidth/2, 50);
		}
	}
	
	/**
	 * Parsing method for PlayGameScreen's global BottomPipe variables
	 * @param bp1 The first BottomPipe
	 * @param bp2 The second BottomPipe
	 */
	public void setBottomPipe(BottomPipe bp1, BottomPipe bp2) {
		this.bp1 = bp1;
		this.bp2 = bp2;
	}
	
	/**
	 * Parsing method for PlayGameScreen's global TopPipe variables
	 * @param tp1 The first TopPipe
	 * @param tp2 The second TopPipe
	 */
	public void setTopPipe(TopPipe tp1, TopPipe tp2) {
		this.tp1 = tp1;
		this.tp2 = tp2;
	}
	
	/**
	 * Parsing method for PlayGameScreen's global Bird variable
	 * @param bird The Bird object
	 */
	public void setBird(Bird bird) {
		this.bird = bird;
	}
	
	/**
	 * Method called to invoke an increase in the variable tracking the current
	 * jump score
	 */
	public void incrementJump() {
		successfulJumps++;
	}
	
	/**
	 * Method called to return the current jump score
	 * @return
	 */
	public int getScore() {
		return successfulJumps;
	}
	
	/**
	 * Method called to parse a message onto the screen
	 * @param message The message to parse
	 */
	public void sendText(String message) {
		this.message = message;
	}
}

